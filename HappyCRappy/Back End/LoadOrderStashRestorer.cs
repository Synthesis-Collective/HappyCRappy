using DynamicData;
using Mutagen.Bethesda.Plugins;
using Noggog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace HappyCRappy;

public class LoadOrderStashRestorer
{
    private readonly IEnvironmentStateProvider _environmentStateProvider;

    public LoadOrderStashRestorer(IEnvironmentStateProvider environmentStateProvider)
    {
        _environmentStateProvider = environmentStateProvider;
    }

    public void ApplyStash(LoadOrderStash stash, List<ModKey> currentLoadOrder)
    {
        var path = _environmentStateProvider.LoadOrderFilePath;

        if (path == null)
        {
            MessageBox.Show("Error: no load order file path detected");
            return;
        }

        else if (!File.Exists(path))
        {
            MessageBox.Show("Error: no file exists at " + path);
            return;
        }

        bool isMO2file = false;
        try
        {
            var lines = File.ReadAllLines(path);
            if(lines.Any() && lines.First().Equals("# This file was automatically generated by Mod Organizer."))
            {
                isMO2file = true;
            }
        }
        catch
        {

        }

        currentLoadOrder.RemoveWhere(x => stash.ModChunks.SelectMany(chunk => chunk.Mods).Contains(x));

        List<string> errorMessages = new();

        foreach (var chunk in stash.ModChunks)
        {
            int position = ComputeChunkPosition(chunk, currentLoadOrder, errorMessages);

            if (position >= 0)
            {
                currentLoadOrder.AddOrInsertRange(chunk.Mods, position);
            }
        }

        if (errorMessages.Any())
        {
            MessageBox.Show(string.Join(Environment.NewLine, errorMessages));
        }

        List<string> outputLines = new();
        if (isMO2file)
        {
            outputLines.Add("# This file was automatically generated by Mod Organizer.");
        }

        foreach (var mod in currentLoadOrder)
        {
            string modName = mod.FileName;
            var loadOrderListing = _environmentStateProvider.LoadOrder?.Where(x => x.Key.Equals(mod)).FirstOrDefault() ?? null;
            if(loadOrderListing != null && loadOrderListing.Value.Enabled)
            {
                modName = "*" + modName;
            }
            outputLines.Add(modName);
        }

        _environmentStateProvider.LinkCache?.Dispose();
        _environmentStateProvider.LoadOrder?.Dispose();

        try
        {
            File.WriteAllLines(path, outputLines);
        }
        catch (Exception ex)
        {
            MessageBox.Show("Failed to apply load order. Error: " + ex.Message);
        }
    }

    private int ComputeChunkPosition(LoadOrderBlock block, List<ModKey> currentLoadOrder, List<string> errorMessages)
    {
        int precedingPos = -1;
        int subsequentPos = -1;

        if (block.PlaceAfter != null)
        {
            var precedingMod = block.PlaceAfter;

            if(currentLoadOrder.Contains(precedingMod.Value))
            {
                precedingPos = currentLoadOrder.IndexOf(precedingMod.Value);
            }
            else
            {
                errorMessages.Add("Could not find Preceding Mod in the current load order: " + precedingMod.Value.FileName);
            }
        }

        if (block.PlaceBefore != null)
        {
            var followingMod = block.PlaceBefore;

            if (currentLoadOrder.Contains(followingMod.Value))
            {
                subsequentPos = currentLoadOrder.IndexOf(followingMod.Value);
            }
            else
            {
                errorMessages.Add("Could not find Subsequent Mod in the current load order: " + followingMod.Value.FileName);
            }
        }

        // if both the subsequent and preceding mods are present in the load order, prioritize placing block right before the subsequent mod
        if (subsequentPos >= 0)
        {
            return subsequentPos;
        }
        // otherwise place the block after the preceding mod
        else if (precedingPos >= 0)
        {
            return precedingPos + 1;
        }

        return -1;
    }
}
